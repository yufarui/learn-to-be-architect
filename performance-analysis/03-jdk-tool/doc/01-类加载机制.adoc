= java的类加载过程
:doctype: book
:encoding: utf-8
:lang: zh-cn
:toc: left
:toc-title: 导航目录
:toclevels: 4
:sectnums:
:sectanchors:

:hardbreaks:
:experimental:
:icons: font

pass:[<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">]

== java命令执行代码流程

执行流程参考::
https://my.oschina.net/vbird/blog/1510800[jvm-启动流程-参考]

.java命令基础启动方式
[source]
----
java [<packageName>.]<className>

java -jar <jarName>.jar
----

.流程步骤的修改和创建
[plantuml,01-image/java_start.png,width=60%]
--
@startuml

:使用java命令执行代码;

fork
->1.创建classLoader;
#aqua:windows环境,jdk/bin/java.exe调用底层
jvm.dll创建jvm虚拟机,linxu下为libjvm.so;

#aquamarine:jvm通过c++创建BootstrapClassLoader,
并由此classLoader创建其他类加载器;

detach
fork again

->2.创建class;
#orange:由类加载器,加载所需的类;

#pink:执行程序Main方法;

#pink:运行结束,销毁jvm;

detach
forkend

@enduml
--

[NOTE]
====
使用kbd:[locate libjvm.so]
可以快速地在linux下找到文件
====

== classLoader的加载过程
https://blog.csdn.net/chaofanwei2/article/details/51335278[Launch-初始化过程-参考]

.类加载器初始化
[plantuml,01-image/launcher_init.png,width=60%]
--
@startuml

#orange:Classloader#initSystemClassLoader;
->1.获取初始系统类加载器;
#orangered:Launcher#getLauncher;
->2.Launcher初始化,并依次加载类加载器;
#aquamarine:加载ExtClassLoader;
note right
System.getProperty("java.ext.dirs");
end note
#aquamarine:加载AppClassLoader;
note right
System.getProperty("java.class.path");
end note
@enduml
--

[TIP]
====
String javaClassPath = System.getProperty("java.class.path");

你可以从java.class.path下拿到应用程序所属的类

====

====
[source,java]
----

/**
 * 类加载时，设置了ContextClassLoader
 */
ClassLoader scl = ClassLoader.initSystemClassLoader();
Thread.currentThread().setContextClassLoader(scl);<1>

/**
 * 若无指定，子线程继承父线程ContextClassLoader
 */
private Thread(...) {<2>
    
    Thread parent = currentThread();
    ...
    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    ...
----
<1>java会在线程中设置线程上下文类加载器
<1>子线程通过构造函数会继承父线程的contextClassLoader
====

== 类加载机制
https://juejin.cn/post/6844903564804882445[类加载机制-参考]

[plantuml,01-image/load_class_process.png]
--
@startmindmap
<style>
mindmapDiagram {
    rootNode {
        BackgroundColor lightBlue
    }
    :depth(1) {
      BackGroundColor white
    }
    :depth(2) {
        BackgroundColor lightGreen
    }
    :depth(3) {
        BackgroundColor pink
    }
}
</style>

* 类的加载过程
** 加载
*** 查找和导入Class文件\n使用时加载
** 链接
*** 把类的二进制数据合并到JRE中
*** 验证
**** 检查载入Class文件数据的正确性
*** 准备
**** 给类的静态变量分配内存，并赋予默认值
*** 解析
**** 符号引用转为直接引用\n静态方法(static method)转换为静态链接
** 初始化
*** 对类的静态变量初始化为指定的值，执行静态代码块

@endmindmap
--

.加载阶段
****
相对于类的加载过程的其他阶段，加载阶段是开发期相对来说可控性比较强，该阶段既可以使用系统提供的类加载器完成，也可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式
****

== 双亲委托与类的加载

推荐阅读::
https://juejin.cn/post/6844903550300979214[]

SPI的理解::
https://www.cnblogs.com/xrq730/p/11440174.html[]

=== 关于SPI中的类加载机制

通过线程上下文类加载器,SPI可以从AppClassLoader拿到对应的服务子类;

=== 关于tomcat的类加载机制

不同目录下的jar包的共享与隔离

image::01-image/tomcat_class_loader.png[]


